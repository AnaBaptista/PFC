/**
 * It draws dinamically the tree generated by all data files
 * @param id {Array} populate id
 */
function getPopulateTree (id) {
  getTree(`/populate/data/${id}/tree`, 'data-file-tree')
}

/**
 * It draws dinamically the tree that belongs to specified
 * individual mapping
 * @param id {String} populate id
 * @param ind {String} individual mapping id
 */
function getPopulateIndividualTree (id, ind) {
  getTree(`/populate/data/${id}/individual/${ind}/tree`, 'individual-tree')
}

/**
 * Generic function that draws a tree into element identified by id
 * @param path {String} path to get the tree
 * @param id {String} html element id
 */
function getTree (path, id) {
  fetch(path)
    .then(handleError)
    .then(res => res.json())
    .then(tree => {
      document.getElementById(id).innerText = ''
      drawIndentedTree(tree, id)
    }).catch(err => console.log(err.message))
}

/**
 * This function transforms an array of nodes into a tree
 * @param root {Array} an array of nodes
 * @param id {String} element id to append the tree
 */
function drawIndentedTree (root, id) {
  root = {children: root, id: 0}
  let margin = {
    top: -10,
    bottom: 10,
    left: 0,
    right: 10
  }
  let width = 300,
    minHeight = 800,
    barHeight = 20,
    barWidth = 50

  let i = 0, duration = 200

  let tree = d3.layout.tree()
    .nodeSize([0, 20])

  let diagonal = d3.svg.diagonal()
    .projection(function (d) { return [d.y, d.x] })

  let svg = d3.select(`#${id}`).append('svg')
    .attr('width', width + margin.left + margin.right)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`)

// set initial coordinates
  root.x0 = 0
  root.y0 = 0

  function collapse (d) {
    if (d.children) {
      d.numOfChildren = d.children.length
      d._children = d.children
      d._children.forEach(collapse)
      d.children = null
    } else {
      d.numOfChildren = 0
    }
  }

  root.children.forEach(collapse)
  update(root)

  function update (source) {
    // Compute the flattened node list. TODO use d3.layout.hierarchy.
    let nodes = tree.nodes(root)

    let height = Math.max(minHeight, nodes.length * barHeight + margin.top + margin.bottom)

    d3.select('svg').transition()
      .duration(duration)
      .attr('height', height)

    // Compute the "layout".
    nodes.forEach(function (n, i) {
      n.x = i * barHeight
      // n.y = n.depth * 20
    })

    // Update the nodesâ€¦
    let node = svg.selectAll('.node')
      .data(nodes, function (d) {
        return d.index || (d.index = ++i)
      })

    let nodeEnter = node.enter().append('g')
      .attr('class', 'node')
      .style('opacity', 0.001)
      .attr('transform', function (d) {
        return `translate(${source.y0}, ${source.x0})`
      })
      .attr('id', (d) => {
        return `${d.id}`
      })

    // Enter any new nodes at the parent's previous position.
    nodeEnter.append('rect')
      .attr('y', -barHeight / 4)
      .attr('x', -barWidth / 8)
      .attr('height', barHeight / 2)
      .attr('width', barWidth / 4)
      .attr('rx', 7)
      .attr('ry', 7)
      .on('click', click)

    nodeEnter.append('text')
      .attr('dy', 4)
      .attr('dx', -3)
      .attr('id', 'text-symbol')

    node.select('text[id=text-symbol]').text(symbol)

    nodeEnter.append('text')
      .attr('dy', 5)
      .attr('dx', 16)
      .attr('id', 'text-tag')
      .on('click', showNode)
      .text(function (d) {
        let ret = d.tag
        if (d.value) {
          ret = `${ret} value: ${d.value}`
        }
        return ret
      })

    // Transition nodes to their new position.
    nodeEnter.transition()
      .duration(duration)
      .attr('transform', function (d) { return `translate(${d.y}, ${d.x})` })
      .style('opacity', 1)

    node.transition()
      .duration(duration)
      .attr('transform', function (d) { return `translate(${d.y}, ${d.x})` })
      .style('opacity', 1)
      .select('rect')
      .style('opacity', 1)

    // Transition exiting nodes to the parent's new position.
    node.exit().transition()
      .duration(duration)
      .attr('transform', function (d) { return `translate(${source.y}, ${source.x})` })
      .style('opacity', 1e-6)
      .remove()
  }

  // Toggle children on click.
  function click (d) {
    if (d.children) {
      d._children = d.children
      d.children = null
    } else {
      d.children = d._children
      d._children = null
    }
    update(d)
  }

  function symbol (d) {
    return d._children ? (d._children.length === 0 ? '' : '+') : d.children ? '-' : ''
  }

  function showNode (d) {
    changeDataFileNodeToMapping(d)
  }
}

/**
 * This functions dynamically changes the selected node
 * @param node {Object} the selected node
 */
let incrementIds = ['individual-name-to-term', 'data-property-to-term', 'annotation-property-to-term']
function changeDataFileNodeToMapping (node) {
  let id = document.getElementById('data-file-term').innerText
  let elem = document.getElementById(id)
  if (!elem) {
    alertify.warning('Nothing to mapper with this node, choose properties or name')
    return
  }
  let div = document.createElement('div')
  div.id = node.id
  div.innerText = node.tag
  let childDiv = document.createElement('label')
  childDiv.id = node.dataFileId
  childDiv.className = 'dataFileId'
  div.appendChild(childDiv)

  if (incrementIds.includes(id)) {
    elem.appendChild(div)
  } else {
    elem.replaceChild(div, elem.childNodes[0])
  }
}

function clearDataFileNodeToMapping() {
  let id = document.getElementById('data-file-term').innerText
  document.getElementById(id).innerText = ''
}
